import { isIterableObject } from './object';

/**
 * Types of values allowed as values for parameter comparisons. Types that are not defined here will be missing when flattened.
 */
export type ComparatorConditionalValue =
  | string
  | number
  | boolean
  | undefined
  | null
  | Date;

const allowdPrimitiveValueTypes = ['string', 'number', 'boolean', 'undefined'];

/**
 * If the passed value matches [ComparatorConditionalValue], it returns `true`.
 */
export function isComparatorConditionalValue(
  value?: any,
): value is ComparatorConditionalValue {
  const type = typeof value;
  if (allowdPrimitiveValueTypes.includes(type)) return true;
  if (value === null) return true;
  if (value instanceof Date) return true;
  return false;
}

/**
 * Condition source for executing parameter comparisons.
 * No information about objects generated according to this interface condition is lost.
 */
export type ComparatorCondition =
  | ComparatorConditionalValue
  | ComparatorCondition[]
  | {
      [key: string]: ComparatorCondition;
    };

/**
 * In order to perform comparison process efficiently, it is an parameter comparisons execution condition object that has been flat processed.
 */
export interface FlattenedComparatorCondition {
  [key: string]: ComparatorConditionalValue;
}

/**
 * The parameter comparisons execution condition object always takes the form of an object. If the passed condition is a primitive value, this key will be adopted as default.
 */
export const DefaultComparatorConditionName = '_comparator_condition_';

export function traverseAndFlattenComparatorCondition(
  currentNode: any,
  result: FlattenedComparatorCondition,
  flattenedKey?: string,
) {
  // If the object should not be enumerated, cast it to an enum type
  if (isComparatorConditionalValue(currentNode)) {
    currentNode = { [DefaultComparatorConditionName]: currentNode };
  }

  Object.keys(currentNode).forEach((key) => {
    let value = currentNode[key];

    let newKey: string;
    if (flattenedKey === undefined) {
      newKey = key;
    } else {
      newKey = flattenedKey + '.' + key;
    }

    if (isIterableObject(value)) {
      traverseAndFlattenComparatorCondition(value, result, newKey);
    } else if (isComparatorConditionalValue(value)) {
      if (value instanceof Date) value = value.toString();
      result[newKey] = value;
    }
  });
  return result;
}

/**
 * The behavior is almost the same as [createComparatorCondition], but the condition object generated by this method is not lost at all.
 */
export function flattenComparatorCondition(
  condition: ComparatorCondition,
): FlattenedComparatorCondition {
  const flattenedCondition: FlattenedComparatorCondition = {};
  traverseAndFlattenComparatorCondition(condition, flattenedCondition);
  return flattenedCondition;
}

/**
 * Generate a condition object for executing comparisons execution. At this point, constructors such as `Symbol` and `Function` are removed.
 * @param args - Any free parameter
 */
export function createComparatorCondition(
  ...args: any[]
): FlattenedComparatorCondition {
  const flattenedCondition: FlattenedComparatorCondition = {};
  traverseAndFlattenComparatorCondition(args, flattenedCondition);
  return flattenedCondition;
}

/**
 * Returns `true` if the two flattened execution conditions are strict equal
 */
export function isSameFlattendComparatorCondition(
  a: FlattenedComparatorCondition,
  b: FlattenedComparatorCondition,
) {
  const akeys = Object.keys(a);
  const bkeys = Object.keys(b);
  if (akeys.length !== bkeys.length) return false;
  return akeys.every((key) => a[key] === b[key]);
}
